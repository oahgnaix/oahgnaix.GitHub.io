// 2020240013 向豪 大数据201

#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include "windows.h"

#define MAXSIZE 1000
#define ROW 15
#define LINE 15
#define RATIO 0.6875 // 44/64的比例
#define DFDIR -1 // 方向默认 值
#define PASS 0 // 通路
#define WALL 1 // 墙
#define ENTRY 2 // 入口
#define EXIT 3 // 出口
#define WALK 4 // 走过
#define DEAD 5 // 死路

typedef struct {
    int x;
    int y;
    int dir; // 方向
} Node;
typedef struct {
    int top;
    Node *data;
} SqStack;

void Map(int map[][LINE]); // 生成地图

void KnuthShuffle(int map[], int length); // 洗牌算法

void swapInt(int *a, int *b); // 辅助洗牌算法 交换

void PrintMap(int map[][LINE]); // 打印迷宫地图

boolean InitStack(SqStack *stack); // 初始化

void Walk(SqStack *stack, int in_x, int in_y, int map[][LINE]); // 移动迷宫

boolean Push(SqStack *stack, Node node); // 压栈

boolean IsFull(SqStack *stack); // 判栈满

boolean IsEmpty(SqStack *stack); // 判栈空

Node GetTop(SqStack *stack); // 取栈顶元素

void Pop(SqStack *stack); // 出栈 (这里用void是以下代码中保证无需判断)

void color(short x); // 自定义函根据参数改变颜色


/**
 * <h2>顺序栈实验</h2>
 * <h3>随机迷宫问题</h3>
 * <h3>注意：请在Dos窗口下运行</h3>
 * @return 0
 */
int main() {

    color(1);
    printf("  使用顺序栈解决迷宫通路问题 \n");
    color(15);
    printf("==============================\n");
    color(4);
    printf("Ｘ--走过的无效通路");
    color(9);
    printf("  囚--起点\n");
    color(13);
    printf("Ｏ--走过的有效通路");
    color(11);
    printf("  口--终点\n");
    color(15);
    printf("------------------------------\n");

    srand(time(NULL));

    int map[ROW][LINE];
    Map(map);

    SqStack stack;
    if (!(InitStack(&stack))) {
        printf("顺序栈初始化失败~~\n");
        return 0;
    }

    int in_x, in_y;
    for (int i = 0; i < ROW; i++) {
        for (int j = 0; j < LINE; j++) {
            if (map[i][j] == ENTRY) {
                in_x = i;
                in_y = j;
            }
        }
    }

    Walk(&stack, in_x, in_y, map);

    color(15);
    printf("------------------------------\n");

    getchar();
}

void Map(int map[][LINE]) {
    int length = (ROW - 2) * (LINE - 2); // 8 * 8 内区域
    int randArr[length];
    for (int i = 0; i < length; i++) {
        if (i == 0) {
            randArr[i++] = ENTRY;
            randArr[i++] = EXIT;
        }
        if (i < (length * RATIO) + 2) {
            randArr[i] = PASS;
        } else {
            randArr[i] = WALL;
        }
    }
    KnuthShuffle(randArr, length); // 打乱 内区域
    // 赋值整张地图
    for (int i = 0; i < ROW; i++) {
        for (int j = 0; j < LINE; j++) {
            // 这里一个小技巧：只要前面四个表达式一个为假，说明未到边界赋值，保证Length不会越界
            if (i != 0 && i != ROW - 1 && j != 0 && j != LINE - 1 && length--) {
                map[i][j] = randArr[length];
            } else {
                map[i][j] = WALL;
            }
        }
    }
}

void KnuthShuffle(int map[], int length) {
    for (int i = length - 1; i >= 1; i--) {
        swapInt(&map[i], &map[rand() % (i + 1)]);
    }
}

void swapInt(int *a, int *b) {
    int t;
    t = *a;
    *a = *b;
    *b = t;
}

void PrintMap(int map[][LINE]) {
    for (int i = 0; i < ROW; i++) {
        for (int j = 0; j < LINE; j++) {
            switch (map[i][j]) {
                case PASS:
                    printf("　");
                    break;
                case WALL:
                    color(10);
                    printf("围");
                    break;
                case ENTRY:
                    color(9);
                    printf("囚");
                    break;
                case EXIT:
                    color(11);
                    printf("口");
                    break;
                case WALK:
                    color(13);
                    printf("Ｏ");
                    break;
                case DEAD:
                    color(4);
                    printf("Ｘ");
                    break;
            }
        }
        printf("\n");
    }
}

boolean InitStack(SqStack *stack) {
    stack->data = malloc(sizeof(Node) * MAXSIZE);
    if (!(stack->data)) {
        return FALSE;
    }
    stack->top = 0;
    return TRUE;
}

void Walk(SqStack *stack, int in_x, int in_y, int map[][LINE]) {
    // 起点先入栈，为后续循环做铺垫
    Node node; // 生成当前位置(起点)
    node.x = in_x;
    node.y = in_y;
    node.dir = DFDIR;
    // 无方向
    Push(stack, node); // 起点入栈

    while (!(IsEmpty(stack))) { // 无路可走的情况，回到起点
        node = GetTop(stack); // 取出当前位置
        if (map[node.x][node.y] == EXIT) { // 判断当前位置是否是终点
            PrintMap(map); // 到终点，打印路径地图
            break;
        } else { // 如果不是终点，继续走
            int i, j, k;
            for (i = node.dir + 1; i < 4; i++) { // 判断当前位置各个方向是否可走
                switch (i) {
                    case 0: // 上
                        j = node.x - 1;
                        k = node.y;
                        break;
                    case 1: // 右
                        j = node.x;
                        k = node.y + 1;
                        break;
                    case 2: // 下
                        j = node.x + 1;
                        k = node.y;
                        break;
                    case 3: // 左
                        j = node.x;
                        k = node.y - 1;
                        break;
                }
                if (map[j][k] == PASS || map[j][k] == EXIT) { // 判断这个方向 是否可走
                    Node tNode; // 生成下一个位置
                    tNode.x = j;
                    tNode.y = k;
                    tNode.dir = DFDIR;

                    stack->data[stack->top - 1].dir = i; // 记录当前位置行走方向
                    Push(stack, tNode); // 下一个位置入栈
                    if (map[j][k] == PASS) {
                        map[j][k] = WALK; // 记为走过
                    }
                    break; // 退出这个位置的方向查找循环
                }
            }
            if (i == 4) { // 四个方向都判断完，但是走不通
                if (!(map[node.x][node.y] == ENTRY)) { // 保证起点不被置为ENTRY
                    map[node.x][node.y] = DEAD; // 把当前位置，记为死路
                }
                Pop(stack); // 当前位置出栈
            }
        }
    }
    if (IsEmpty(stack)) {
        PrintMap(map);
        color(12);
        printf("\t无路可走，死翘翘了~~\n");
    }
}

boolean Push(SqStack *stack, Node node) {
    if (IsFull(stack)) {
        return FALSE;
    }
    stack->data[stack->top++] = node;
    return TRUE;
}

boolean IsFull(SqStack *stack) {
    return stack->top == MAXSIZE;
}

boolean IsEmpty(SqStack *stack) {
    return stack->top == 0;
}

Node GetTop(SqStack *stack) {
    return stack->data[stack->top - 1];
}

void Pop(SqStack *stack) {
    stack->top--;
}

void color(short x) {
    if (x >= 0 && x <= 15) { // 参数在0-15的范围颜色
        SetConsoleTextAttribute( // 调用设置控制台文本属性函数(调用获取句柄函数(不理解), 不理解)
                GetStdHandle(STD_OUTPUT_HANDLE), x);    // 只有一个参数，改变字体颜色
    } else { // 默认的颜色白色
        SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 7);
    }
    /*
    解析一波：
    color(0);	printf("黑色\n");
    color(9); 	printf("蓝色\n");
    color(2); 	printf("绿色\n");
    color(3); 	printf("湖蓝色\n");
    color(4);  	printf("红色\n");
    color(5);  	printf("紫色\n");
    color(11); 	printf("黄色\n");
    color(15);  	printf("白色\n");
    color(8);  	printf("灰色\n");
    color(9); 	printf("淡蓝色\n");
    color(10); 	printf("淡绿色\n");
    color(11); 	printf("淡浅绿色\n");
    color(12);  printf("淡红色\n");
    color(11); 	printf("淡紫色\n");
    color(11); 	printf("淡黄色\n");
    color(15); 	printf("亮白色\n");
    color(16);    // 因为这里大于15，恢复默认的颜色
     */
}
