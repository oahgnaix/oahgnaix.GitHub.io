#include <stdio.h>
#include <time.h>
#include "windows.h"

#define MAXSIZE 1000
#define ROW 8
#define LINE 8
#define RATIO 0.6875 // 44/64的比例
#define COORDINATE -1 // 坐标默认 值
#define PASS 0 // 通路
#define WALL 1 // 墙
#define ENTRY 2 // 入口
#define EXIT 3 // 出口
#define WALK 4 // 走过
#define DEAD 5 // 死路

typedef struct Box {
    int x;           // 点的横坐标（行）
    int y;           // 点的纵坐标（列）
    int pre;         // 上一个点的下标
} Box;

typedef struct {
    Box *base;
    int front;
    int rear;
} SqQueue;

void Map(int map[][LINE]); // 生成地图

void KnuthShuffle(int map[], int length); // 洗牌算法

void swapInt(int *a, int *b); // 辅助洗牌算法 交换

void PrintMap(int map[][LINE]); // 打印迷宫地图

boolean InitQueue(SqQueue *queue); // 循环队列的初始化

void Walk(SqQueue *queue, int in_x, int in_y, int map[][LINE]); // 移动迷宫

boolean EnQueue(SqQueue *queue, Box node); // 循环队列入队列

boolean IsFull(SqQueue *queue); // 判队满

boolean IsEmpty(SqQueue *queue); // 判队空

Box DeQueue(SqQueue *queue); // 循环队列出队列

void ShowPath(SqQueue *queue, int end, int map[][LINE]); // 求解最短路径

void Color(short x); // 自定义函根据参数改变颜色

/**
 * <h2>顺序队列实验</h2>
 * <h3>随机迷宫问题</h3>
 * <h3>注意：请在Dos窗口下运行</h3>
 * <h4>非循环队列，并不是真的退出队列</h4>
 * @return 0
 */
int main() {

    Color(1);
    printf("  使用队列解决迷宫通路问题 \n");
    Color(15);
    printf("==============================\n");
    Color(4);
    printf("Ｘ--走过的无效通路");
    Color(9);
    printf("  囚--起点\n");
    Color(13);
    printf("Ｏ--走过的有效通路");
    Color(11);
    printf("  口--终点\n");
    Color(15);
    printf("------------------------------\n");

    srand(time(NULL));

    int map[ROW][LINE];
    Map(map);

    SqQueue queue;
    if (!(InitQueue(&queue))) {
        printf("顺序队列初始化失败~~\n");
        return 0;
    }

    int in_x, in_y;
    for (int i = 0; i < ROW; i++) {
        for (int j = 0; j < LINE; j++) {
            if (map[i][j] == ENTRY) {
                in_x = i;
                in_y = j;
            }
        }
    }

    Walk(&queue, in_x, in_y, map);

    Color(15);
    printf("------------------------------\n");

    getchar();
}

void Map(int map[][LINE]) {
    int length = (ROW - 2) * (LINE - 2); // 8 * 8 内区域
    int randArr[length];
    for (int i = 0; i < length; i++) {
        if (i == 0) {
            randArr[i++] = ENTRY;
            randArr[i++] = EXIT;
        }
        if (i < (length * RATIO) + 2) {
            randArr[i] = PASS;
        } else {
            randArr[i] = WALL;
        }
    }
    KnuthShuffle(randArr, length); // 打乱 内区域
    // 赋值整张地图
    for (int i = 0; i < ROW; i++) {
        for (int j = 0; j < LINE; j++) {
            // 这里一个小技巧：只要前面四个表达式一个为假，说明未到边界赋值，保证Length不会越界
            if (i != 0 && i != ROW - 1 && j != 0 && j != LINE - 1 && length--) {
                map[i][j] = randArr[length];
            } else {
                map[i][j] = WALL;
            }
        }
    }
}

void KnuthShuffle(int map[], int length) {
    for (int i = length - 1; i >= 1; i--) {
        swapInt(&map[i], &map[rand() % (i + 1)]);
    }
}

void swapInt(int *a, int *b) {
    int t;
    t = *a;
    *a = *b;
    *b = t;
}

void PrintMap(int map[][LINE]) {
    for (int i = 0; i < ROW; i++) {
        for (int j = 0; j < LINE; j++) {
            switch (map[i][j]) {
                case PASS:
                    printf("　");
                    break;
                case WALL:
                    Color(10);
                    printf("围");
                    break;
                case ENTRY:
                    Color(9);
                    printf("囚");
                    break;
                case EXIT:
                    Color(11);
                    printf("口");
                    break;
                case WALK:
                    Color(13);
                    printf("Ｏ");
                    break;
                case DEAD:
                    Color(4);
                    printf("Ｘ");
                    break;
            }
        }
        printf("\n");
    }
}

boolean InitQueue(SqQueue *queue) {
    queue->base = (Box *) malloc(sizeof(Box) * MAXSIZE);
    if (!(queue->base)) {
        return FALSE;
    }
    queue->front = queue->rear = 0;
    return TRUE;
}

void Walk(SqQueue *queue, int in_x, int in_y, int map[][LINE]) {
    // 起点先入队列
    Box node; // 生成当前位置(起点)
    node.x = in_x;
    node.y = in_y;
    node.pre = COORDINATE; // 起点位置下标 -1

    EnQueue(queue, node); // 起点入队列

    while (!(IsEmpty(queue))) { // 无路可走的情况，回到起点
        node = DeQueue(queue); // 取出队头位置 队头指针front++

        if (map[node.x][node.y] == EXIT) { // 判断当前位置是否是终点
            ShowPath(queue, queue->front, map);
            PrintMap(map);
            return;
        }
        int dir; // 装方向
        Box tNode; // 生成下一个位置
        for (dir = 0; dir < 4; dir++) { // 判断当前位置各个方向是否可走
            switch (dir) {
                case 0:
                    tNode.x = node.x - 1;
                    tNode.y = node.y;
                    break;
                case 1:
                    tNode.x = node.x;
                    tNode.y = node.y + 1;
                    break;
                case 2:
                    tNode.x = node.x + 1;
                    tNode.y = node.y;
                    break;
                case 3:
                    tNode.x = node.x;
                    tNode.y = node.y - 1;
                    break;
            }
            if (map[tNode.x][tNode.y] == PASS || map[tNode.x][tNode.y] == EXIT) { // 判断这个方向 是否可走
                tNode.pre = queue->front - 1; // 把节点位置的下标给 新位置
                EnQueue(queue, tNode);
                if (map[tNode.x][tNode.y] == PASS) {
                    map[tNode.x][tNode.y] = DEAD; // 将下一个位置置为死路（即走过）
                }
            }
        }
    }
    if (IsEmpty(queue) && map[node.x][node.y] != EXIT) {
        PrintMap(map);
        Color(12);
        printf("\t无路可走，死翘翘了~~\n");
    }
}

boolean EnQueue(SqQueue *queue, Box node) {
    if (IsFull(queue)) {
        return FALSE;
    }
    queue->base[queue->rear] = node; // 新元素插入队尾
    queue->rear = queue->rear + 1; // 队尾指针加 1
    return TRUE;
}

boolean IsFull(SqQueue *queue) {
    return queue->rear + 1 == queue->front; // 非循环队列
}

boolean IsEmpty(SqQueue *queue) {
    return queue->rear == queue->front;
}

Box DeQueue(SqQueue *queue) {
    return queue->base[queue->front++]; // 取出队头元素，并把其出队列
}

void ShowPath(SqQueue *queue, int end, int map[][LINE]) {
    int i, tmp;
    for (i = end - 1; i >= 0;) {
        tmp = queue->base[i].pre;
        queue->base[i].pre = COORDINATE;
        i = tmp;
    }
    for (i = 0; i < end; i++) {
        if (queue->base[i].pre == COORDINATE && map[queue->base[i].x][queue->base[i].y] != ENTRY
            && map[queue->base[i].x][queue->base[i].y] != EXIT) {
            map[queue->base[i].x][queue->base[i].y] = WALK;
        }
    }
}

void Color(short x) {
    if (x >= 0 && x <= 15) { // 参数在0-15的范围颜色
        SetConsoleTextAttribute( // 调用设置控制台文本属性函数(调用获取句柄函数(不理解), 不理解)
                GetStdHandle(STD_OUTPUT_HANDLE), x);    // 只有一个参数，改变字体颜色
    } else { // 默认的颜色白色
        SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 7);
    }
}